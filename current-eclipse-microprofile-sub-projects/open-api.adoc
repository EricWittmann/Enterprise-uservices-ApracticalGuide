= OpenAPI

*What is the business problem that this sub-project addresses.
How does this sub-project go about addressing it.
High-level description of sub-project API.
Snippet(s) of sample code that implements sub-project.
Eclipse resources/GitHub coordinates for sub-project.*

The Mobile force that fuels the Digital Economy led to the necessity for businesses to establish an omni-channel approach to development in order to optimize costs, increase efficiencies and improve customer experience. An enabler to this approach was APIs, which led to the API Economy and concepts such as API-led or API-first development practices. In addition, microservices architecture has become the architecture of choice for modern development and API-based, i.e. RESTful, communication among microservices has been adopted as the de-facto standard because they are a good fit for the "smart endpoints and dumb pipes",   "decentralized governance" and "decentralized data management" characteristics of microservices. However, as the number of microservices increases in a microservices architecture, their management can become unwieldy. Microservices can be managed via their APIs. Management, security, load balancing, and throttling are policies that can be applied to APIs fronting microservices. MicroProfile OpenAPI provides a set of Java interfaces and programming models which allow Java developers to natively produce OpenAPI v3 documents from their JAX-RS applications.


A fully processed OpenAPI document must be available at the root URL /openapi, as a HTTP GET operation.

.For example:
[source,bash]
----
GET http://myHost:myPort/openapi
----

The protocol required is http. Vendors are encouraged, but not required, to support the https protocol as well, to enable a secure connection to the OpenAPI endpoint.

== Configuration

Configuration of various parts of this specification is provided via the MicroProfile Config mechanism.There are various ways to inject these configuration values into an MP OpenAPI framework, including the default ConfigSource as well as custom ConfigSource.
There are many configurable items. Here is a subset of them.  For a complete list, please refer to the MicroProfile OpenAPI Specification document listed later in this chapter.

.Subset of MicroProfile OpenAPI configuration items
[width="80%",cols="1,^2",options="header"]
|=========================================================
|Configuration item |Description

|mp.openapi.scan.disable | Configuration property to disable annotation scanning. Default value is false.

|mp.openapi.servers | Configuration property to specify the list of global servers that provideconnectivity information. For example,mp.openapi.servers=https://xyz.com/v1,https://abc.com/v1

|mp.openapi.servers.path. | Prefix of the configuration property to specify an alternative list of servers to service all operations in a path. For example,mp.openapi.servers.path./airlines/bookings/\{id}=https://xyz.io/v1

|mp.openapi.servers.operation. | Prefix of the configuration property to specify an alternative list of servers to service an operation. Operations that want to specify an alternative list of servers must define an operationId, a unique string used to identify the operation. For example,mp.openapi.servers.operation.getBooking=https://abc.io/v1

|=========================================================

== Generating the OpenAPI document

The MP OpenAPI specification requires the generation of a valid OpenAPI document from pure JAX-RS 2.0 applications. Application developers new to OpenAPI can just deploy their existing JAX-RS application into a MP OpenAPI vendor and check out the output from /openapi!

The application developer then has a few choices:

1. Augment those JAX-RS annotations with the OpenAPI Annotations.

2. Take the initial output from /openapi as a starting point to document your APIs via Static OpenAPI files. Static files can also be written before any code, which is an approach often adopted by enterprises to lock-in the contract of the API, i.e. API-first development practice.

3. Use the Programming model to provide a bootstrap (or complete) OpenAPI model tree.

Additionally, a Filter can be used to update the OpenAPI model after it has been built from the previously described documentation mechanisms.

== Annotations

There are many MicroProfile OpenAPI annotations that an application developers can use in their code.  The following is a partial list of them. For a complete list of MicroProfile OpenAPI annotations, please refer to the please to the MicroProfile OpenAPI Specification document listed later in this chapter.

Here are some code samples using annotations:

.Subset of MicroProfile OpenAPI annotations
[width="80%",cols="1,^2",options="header"]
|=========================================================
|Annotation |Description

|@APIResponse | Describes a single response from an API operation.

|@APIResponse | Describes a single response from an API oper
|@Content | Provides schema and examples for a particular media type.

|@Operation | Describes an operation or typically a HTTP method against a specific path.

|@Parameter | Describes a single operation parameter.

|@Schema | Allows the definition of input and output data types.

|=========================================================

Some usage examples of the MicroProfile OpenAPI annotations are:

.Sample 1 - Simple operation description (abbreviated)
[source,bash]
----
@GET
@Path("/findByStatus")
@Operation(summary = "Finds Pets by status",
           description = "Multiple status values can be provided with comma separated strings")
public Response findPetsByStatus(...)
{ ... }
----

.Output for Sample 1
[source,bash]
----
/pet/findByStatus:
  get:
    summary: Finds Pets by status
    description: Multiple status values can be provided with comma separated strings
    operationId: findPetsByStatus
----

.Sample 2 - Operation with different responses(abbreviated)
[source,bash]
----
@GET
@Path("/{username}")
@Operation(summary = "Get user by user name")  @APIResponse(description = "The user",
             content = @Content(mediaType = "application/json",
                                schema = @Schema(implementation = User.class))),
@APIResponse(responseCode = "400", description = "User not found")
public Response getUserByName(
        @Parameter(description = "The name that needs to be fetched. Use user1 for  testing. ", required = true) @PathParam("username") String username)
{...}
----



== Eclipse resources/GitHub coordinates for MicroProfile OpenAPI
The MicroProfile OpenAPI project can be found at following location:

link:https://github.com/eclipse/microprofile-open-api[https://github.com/eclipse/microprofile-open-api]